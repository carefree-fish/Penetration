验证顺序为：

先看是否有二次渲染、二次操作（多数没有）

再看判断验证类型

再看中间件类型等



## 前端验证

### 验证：

通过js验证，比较明显的如三种弹窗（alert、confirm、prompt）

### 绕过：

1. 把网页下载到本地，把验证代码扣下来，设置提交地址（更改表单的action），提交地址可以通过请求包的目的地址查看
2. 如果把js禁用掉，则无验证。但一些正常js被禁用可能影响上传操作
3. 先把后缀改为允许上传的后缀，然后抓包，改回后缀名



## 后端验证

$_FILES 专门接收 文件上传操作的数据

```
<form method='post'>
	<input class="input_file" type="file" name="upload_file"/>
	<input class="button" type="submit" name="submit" value="上传"/>
</form>
用$_FILES['upload_file']['name']来接收文件名
后面一个[]：
type为MIME类型，size为文件大小
```

用接收的type等 配合if语句进行判断

### 验证方式及绕过

- 后缀名：黑名单，白名单等（黑名单会提示文件不允许上传，白名单会提示文件类型不正确）

- 文件类型：MIME信息

- 文件头：内容头信息

#### 后缀名验证

##### 黑名单

明确不允许上传 的后缀格式

eg. php asp jsp aspx cgi war

若黑名单定义不完全，如有的格式，如php5，Phtml可能没被定义进黑名单

- 多重文件后缀 - strrchr函数来防护

- .htaccess解析

  apache支持 htaccess文件，此文件可以规定将某种type的文件解析为另一种文件格式，实现伪静态

  如果网站过滤采用黑名单，没过滤htaccess文件

  则可以上传htaccess文件实现当前文件夹及子文件夹的解析覆盖，之后就恶意上传任意文件

  文件内容格式...

  不同版本，.htaccess格式不同

- 大小写绕过

  黑名单，且未进行大小写过滤

  则可以将文件后缀某部分改变大小写

- 点绕过/空格绕过

  Windows特性

  未进行 收尾去空：

  后缀名 后多跟了个空格，与黑名单匹配不上

  在数据包中加上空格，上传后Windows系统自动去掉后缀名的末尾空格（Linux也是），从而又变为php文件

  未进行 末尾去点：
  
  系统不允许文件后缀又加一个点


- ::$$DATA绕过

  Windows下 ::$DATA

  Windows中，文件名末尾加上::$DATA，::$DATA之后的数据会被当做文件流处理，不会检测后缀，且保持加...之前的文件名

  访问的时候不用加::$DATA后缀

- 配合解析漏洞

- 双后缀名绕过

- 非循环过滤绕过

  只过滤了一次，用a.php. .这种进行绕过

  应对：字符串替换为空，如php、PhP


- 文件夹绕过

  将图片马文件后缀改为.php/.（看起来像文件夹，因而命名）会被识别为php/.从而绕过，而文件会自动变为以php结尾。参考CVE-2015-2348

- 数组切片验证绕过

  如果以数组来接受文件名，则a.jpg=>['a', '.', 'jpg']

  验证会以数组第一位和最后一位进行结合重新组成文件名

  绕过方式：文件名改为a.php/.jpg=>['a.php/', '.', 'jpg']



##### 白名单

明确可以上传 的后缀格式（非黑即白）

相对比黑名单更安全

都通过定义一个列表，判断是否在里面

- MIME绕过

  更改请求数据包中 Content-Type 的信息

  | 扩展名 | MIME       |
  | ------ | ---------- |
  | jpeg   | image/jpeg |
  | jpg    | image/jpeg |
  | png    | image/png  |
  | gif    | image/gif  |

- %00截断

  php<5.3.4，如5.2

  数据包中，请求路径改为...upload/xxx.php%00a.png

  在后台接收路径时，路径=....upload/xxx.php%00a.png

  %00后面的无效，存储为xxx.php格式

  %00可以视为字符串中的/0，作为字符串结束的标志。

  %00为url编码后的结果，但是get会帮我们把数据中%00解码，而post不会，所以post数据包中，需要现将%00编码成%25%30%30

- 0x00截断

- 0x0a截断

- 结合文件包含

  乖乖上传后，以文件包含来利用

- 结合解析漏洞



#### 文件信息验证

MIME信息：请求数据包中 Content-Type 的信息

可以根据MIME类型判断 文件是什么格式（不严谨）



#### 文件内容验证

- 文件头检测

  文件开头的一串字符

  gif文件：GIF89a、GIF87a

  png：

  jpg：

- php内置函数：getimagesize、exif_imagetype、imagecreateformgif函数等，只能获取图片文件的信息，通过执行此类函数来限制文件类型。

  这种验证方式，只能通过其他漏洞配合文件上传漏洞来利用，如文件包含

- 二次渲染

  图片先上传到服务器，在经过缩放生成符合页面布局的新图片

  （有的图片太大，所以需要缩放处理）

  又分为先上传再过滤，先过滤在上传：

  先上传再过滤：恶意图片已经上传进服务器，可能更名了，加了时间戳什么的，但是可以配合条件竞争来利用

  先过滤在上传：那就GG

  也可以通过将压缩后的图片下载下来，通过插件等来对比文件内容，找到未变化的部分，将其用后面替代

  其中gif文件的变化最明显，只有前面一部分不变

- 条件竞争

  文件刚刚上传到服务器，服务器要对其进行操作，不过网站上一直访问该文件，则有可能文件因为被访问，而未被服务器操作。

  可以利用burpsuite重复发包，同时网站上重复访问



## CVE

#### CVE-2017-12615

Tomcat任意文件上传漏洞，中间件漏洞



## 注意

上传成功后，一般都会返回上传地址（上传到了服务器的哪里，比如/upload/xxx.jpg）



bp抓包，更改数据包中文件格式。但有时会抓不到数据包，因为上传的文件用js提交，并没有提交到服务器



php：后端语言，因为前端返回的代码和源代码不一样

html、javascript：前端语言，前端返回的代码和源代码一样



get数据包会自动解码

post不会，需要自己编码

疑问：

在网站上输入a-a?  b-b?

get：/login.html?user=a-a%3F&password=b-b%3F

post：user=a-a%3F&password=b-b%3F

输入a%00a

get：/login.html?user=a%2500a&password=a%2500a

post：user=a%2500a&password=a%2500a



手动将php文件合并到图片文件中时，都要以16进制格式。因为记事本打开图片文件用的是16进制，所以要把16进制的后门放进去



文件包含漏洞：

将后门文件包含进源文件，将包含的文件已后门的格式来执行

如，某个php文件有文件包含漏洞，则将上传的图片马文件传进此php文件，令其包含图片马文件，从而让图片马文件可以按照php来执行